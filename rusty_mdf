#!/usr/bin/env python3
"""
CLI tool to fix header numbering in Markdown files.
Fixes duplicate numbers, gaps, and inconsistencies while preserving the original structure.
"""

import argparse
import re
import sys
from pathlib import Path


def get_header_level(line: str) -> int | None:
    """Get the header level (1-6) if line is a header, else None."""
    match = re.match(r'^(#{1,6})\s+(.+)$', line)
    if match:
        return len(match.group(1))
    return None


def has_numbering(header_line: str) -> bool:
    """Check if a header already has numbering like '## 1.2. Foo' or '## 1 Foo'."""
    return bool(re.match(r'^#{1,6}\s+\d+(?:\.\d+)*\.?\s+', header_line))


def extract_current_number(header_line: str) -> tuple[int, ...] | None:
    """Extract the numbering from a header like '## 5.2. Foo' -> (5, 2)."""
    match = re.match(r'^#{1,6}\s+(\d+(?:\.\d+)*)\.?\s+(.+)$', header_line)
    if match:
        nums = tuple(int(n) for n in match.group(1).split('.'))
        return nums
    return None


def fix_md_numbering(content: str) -> tuple[str, int]:
    """
    Fix header numbering in markdown content.
    - Main sections (##) get flat numbering: 1, 2, 3...
    - Subsections (###) under a main section get hierarchical: 1.1, 1.2, 1.3...
    - Further subsections continue the pattern
    - First unnumbered H1 is treated as title, not numbered
    Returns (new_content, number_of_fixes).
    """
    lines = content.split('\n')
    level_counts = {}  # level -> current count
    fixes = 0
    new_lines = []
    section_number = 1  # Track the current main section (##) number
    first_h1_processed = False
    
    for line in lines:
        lvl = get_header_level(line)
        
        if lvl is None:
            new_lines.append(line)
            continue
        
        # Skip first unnumbered H1 (treat as title)
        if lvl == 1 and not has_numbering(line) and not first_h1_processed:
            first_h1_processed = True
            new_lines.append(line)
            continue
        
        # Offset: markdown level 1 = H1, level 2 = H2 (main sections), level 3 = H3 (subsections)
        # Use adjusted level for numbering (H2 = 1, H3 = 2, etc.)
        adj_lvl = lvl - 1  # H2 -> 1, H3 -> 2, etc.
        
        current_num = extract_current_number(line)
        
        # Reset counts for levels below current
        for l in range(adj_lvl + 1, 7):
            level_counts.pop(l, None)
        
        # Get/initialize count for this adjusted level
        if adj_lvl not in level_counts:
            level_counts[adj_lvl] = 0
        level_counts[adj_lvl] += 1
        
        # Determine expected number
        # adj_lvl 1 (H2) gets flat numbering: 1, 2, 3
        # adj_lvl 2 (H3) gets hierarchical: under H2 1 -> 1.1, 1.2
        if adj_lvl == 1:
            # Main sections: 1, 2, 3... (flat)
            expected = level_counts[adj_lvl]
            expected_tuple = (expected,)
        elif adj_lvl == 2:
            # Subsections: 1.1, 1.2, 2.1, 2.2...
            parent_num = level_counts.get(1, 1)
            expected_tuple = (parent_num, level_counts[adj_lvl])
            expected = expected_tuple
        else:
            # Deeper levels: build from all parent levels
            parts = []
            for l in range(1, adj_lvl):
                parts.append(str(level_counts.get(l, 1)))
            parts.append(str(level_counts[adj_lvl]))
            expected_tuple = tuple(int(p) for p in parts)
            expected = expected_tuple
        
        if current_num is None:
            # No number - add one
            header_text = line.lstrip('#').strip()
            if adj_lvl == 1:
                new_line = f"{'#' * lvl} {expected}. {header_text}"
            elif adj_lvl == 2:
                new_line = f"{'#' * lvl} {expected_tuple[0]}.{expected_tuple[1]}. {header_text}"
            else:
                expected_str = '.'.join(map(str, expected_tuple))
                new_line = f"{'#' * lvl} {expected_str}. {header_text}"
            fixes += 1
            new_lines.append(new_line)
        else:
            # Has a number - check if it matches expected
            if adj_lvl == 1:
                if current_num[0] != expected:
                    header_text = line.lstrip('#').strip()
                    header_text = re.sub(r'^\d+(?:\.\d+)*\.?\s*', '', header_text)
                    new_line = f"{'#' * lvl} {expected}. {header_text}"
                    fixes += 1
                    new_lines.append(new_line)
                else:
                    new_lines.append(line)
            elif adj_lvl == 2:
                if len(current_num) < 2 or current_num[0] != expected_tuple[0] or current_num[1] != expected_tuple[1]:
                    header_text = line.lstrip('#').strip()
                    header_text = re.sub(r'^\d+(?:\.\d+)*\.?\s*', '', header_text)
                    new_line = f"{'#' * lvl} {expected_tuple[0]}.{expected_tuple[1]}. {header_text}"
                    fixes += 1
                    new_lines.append(new_line)
                else:
                    new_lines.append(line)
            else:
                if current_num != expected_tuple:
                    header_text = line.lstrip('#').strip()
                    header_text = re.sub(r'^\d+(?:\.\d+)*\.?\s*', '', header_text)
                    expected_str = '.'.join(map(str, expected_tuple))
                    new_line = f"{'#' * lvl} {expected_str}. {header_text}"
                    fixes += 1
                    new_lines.append(new_line)
                else:
                    new_lines.append(line)
    
    return '\n'.join(new_lines), fixes


def main():
    parser = argparse.ArgumentParser(
        description="Fix header numbering in Markdown files"
    )
    parser.add_argument(
        "files",
        nargs="*",
        help="MD files to fix (default: all .md files in current directory)"
    )
    parser.add_argument(
        "-n", "--dry-run",
        action="store_true",
        help="Show what would be changed without modifying files"
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Show detailed output"
    )
    
    args = parser.parse_args()
    
    if args.files:
        files = [Path(f) for f in args.files]
    else:
        files = list(Path('.').glob('*.md'))
    
    if not files:
        print("No .md files found")
        sys.exit(1)
    
    total_fixes = 0
    
    for filepath in files:
        if not filepath.exists():
            print(f"File not found: {filepath}")
            continue
        
        content = filepath.read_text()
        new_content, fixes = fix_md_numbering(content)
        
        if fixes > 0:
            print(f"{filepath}: {fixes} fix(es)", end="")
            if args.dry_run:
                print(" (dry run)")
            else:
                print()
                filepath.write_text(new_content)
            total_fixes += fixes
            
            if args.verbose:
                old_lines = content.split('\n')
                new_lines = new_content.split('\n')
                for i, (old, new) in enumerate(zip(old_lines, new_lines)):
                    if old != new:
                        print(f"  Line {i+1}:")
                        print(f"    - {old}")
                        print(f"    + {new}")
        else:
            if args.verbose:
                print(f"{filepath}: no changes needed")
    
    if not args.verbose:
        print(f"Total: {total_fixes} fix(es)")
    
    sys.exit(0 if total_fixes == 0 else 1)


if __name__ == "__main__":
    main()
